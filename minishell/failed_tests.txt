


SOLVED cd
-----
SOLVED cd /etc -> on minishell goes to private/etc
ChatGPT says that:
The behavior you're seeing might be related to the default behavior of the macOS filesystem.

In macOS, the root directory is actually a symlink to "/private/var/root" instead of the typical "/". This means that when you run the "cd /" command, you're actually being redirected to the "/private" directory.

Similarly, when you run "cd /etc", you're actually being redirected to "/private/etc" instead of "/etc".

To confirm if this is the issue, you can try running the "ls /" command and see if it lists "/private" as one of the directories. If it does, then this is likely the cause of the behavior you're seeing.
-------
SOLVED cd "$PWD/prompt" -> chdir: No such file or directory: ~
-------
cd "doesntexist" 2>/dev/null -> chdir: No such file or directory: doesntexist instead of nothing
In a correctly implemented version of the "cd" command, running "cd "doesntexist" 2>/dev/null" would change the current working directory to a non-existent directory named "doesntexist" and redirect any error messages generated by the command to the "null" device, effectively discarding them.

The "2>" part of the command is a redirection operator that redirects the standard error stream to the file descriptor following it. In this case, "/dev/null" is a special device file that discards any data written to it. So "2>/dev/null" redirects any error messages generated by the "cd" command to /dev/null, effectively suppressing them.

Note that the behavior of the "cd" command might vary depending on the implementation and the operating system. In some implementations, running "cd "doesntexist"" might result in an error message being displayed, even with the redirection to /dev/null.
	SOLUTION
	The error should be redirected to the file instead of stderr
----
SOLVED cd $PWD/file_tests
------
SOLVED cd $OLDPWD/builtins
------
cd "~/Desktop" -> bash: cd: ~/Desktop: No such file or directory (check expansion in error message)

TODO Escape spaces in dir name (or it's fine not to)

------
SOLVED echo $ -> $
------
SOLVED echo -n -n -n bonjour -> bonjour$
------
SOLVED echo -n"-n" bonjour -> -n-n bonjour 2 args		quotes are not trimmed
------
SOLVED echo "-nnnn" -n bonjour	-> bonjour$
------
SOLVED echo "-n -n -n"-n bonjour -> -n -n -n-n bonjour
------
SOLVED echo "-n '-n'" bonjour -> -n '-n' bonjour
------
SOLVED echo "'$USER'" -> 'tim'
------
SOLVED echo "   '$USER' " ->    'tim'
------
SOLVED echo text"$USER" -> texttim
------
SOLVED echo text"'$USER'" ' $USER ' -> text'tim'  $USER
------
SOLVED echo               text "$USER"            "$USER"text -> text tim timtext
------
echo ''''''''''$USER'''''''''' -> tim (it triggers the unclosed quotes error)
------
echo """"""""$USER"""""""" -> tim
------
echo $USER'$USER'text oui oui     oui  oui $USER oui      $USER '' -> tim$USERtext oui oui oui oui tim oui tim
------
SOLVED echo ' \' ' \' ->  \  \
------
echo '\" ' " \"\"" -> \"   ""
------
echo \\\" \\\" \\\" \\\"\\\"\\\" \\\'\\\'\\\' -> \" \" \" \"\"\" \'\'\'
------
SOLVED echo '$'
------
SOLVED echo "'$   bla'" -> '$   bla'
------
SOLVED echo "$   bla" -> $   bla
------
SOLVED ex
------
SOLVED echo "$USER""$USER""$USER" -> timtimtim
------
SOLVED echo text"$USER"test -> texttimtest
------
SOLVED echo '$USER' "$USER" "text \' text" -> $USER tfregni text \' text
------
SOLVED (undefined) export | grep "SHLVL" -> declare -x SHLVL="3"
------
export test=" foo   bar " -> foo bar
------
export test="  ' foo    bar'  " -> ' foo bar'
------
export test="   '   $USER  bla ' " -> ' tfregni bla '
------
echo hello $test -> hello ' tfregni bla '
In bash:
	cmd							stored									output			clean
	export test="'$USER'" -> 				test='tfregni'				'tfregni'
	export test='$USER' -> 					test=$USER					$USER
	export test=$USER -> 					test=tfregni				tfregni
	export test="  ' foo  bar'" -> 			test=  ' foo  bar'			' foo bar'		yes
	export test="  '  foo  $USER   ' " -> 	test=  '  foo  tfregni   '	' foo tfregni '	yes
	export test="    foo   $USER    " -> 	test=    foo   tfregni		foo tfregni		yes
	export test=" '  $USER   foo '  "		test= '  tfregni   foo '	' tfregni foo '	yes
	export test="'   foo  $USER ' "			test='   foo  tfregni '		' foo tfregni '	yes
	export test="'foo  $USER ' "			test='foo  tfregni '		'foo tfregni '	yes
	export test="foo    $USER  "			test=foo    tfregni			foo tfregni

	test="'$USER'"
	echo "'$USER' $test"												'tim' 'tim'

par_node trim_cmd removed free

fixed leak in add param: exec_utils add_param: free(trimmed)
fixed invalid read export.c is_param by deleting i++ after ft_skip_char

test="   foo   bar"
echo $test
==17738== 18 bytes in 2 blocks are definitely lost in loss record 16 of 113
==17738==    at 0x1000B72C5: malloc (vg_replace_malloc.c:388)
==17738==    by 0x100005E9D: ft_strdup (in ./minishell)
==17738==    by 0x10000378A: par_fill_cmd (par_redir.c:54)
==17738==    by 0x1000034ED: par_list_new_node (par_list.c:48)
==17738==    by 0x100002CED: par_list_from_lex (parser.c:51)
==17738==    by 0x100002DD3: parser (parser.c:84)
==17738==    by 0x1000013E5: prompt_routine (prompt.c:59)
==17738==    by 0x100001485: get_prompt (prompt.c:80)
==17738==    by 0x1000011ED: main (main.c:96)
gets fixed removing trim_cmd from echo. why?
fixed by putting back free in par_node trim_cmd

SOLVED echo $ARG (where ARG is not a valid var) segfaults. Fixed in expand_var: protect if !param

whoami | cat -e | cat -e > tmp/file displayes 4 errors: should cut it shorter

